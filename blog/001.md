# First bLog entry

### Step one

- Define a location object that can be linked together with movement commands
    - go north, go up, ...
    - Included a name, description (compound description that includes descriptions of contained items)
- Initial configuration and state saving / restoration
- Beginnings of grammar parser  


### Concerns
- Can I make this interesting enough
    - Will the concrete instances of items have enough configuration to define behavior
    or will a embedding scripting engine be needed (making configuring a new setup much harder)


Differences in CLI and Web

Logging 
- in web mode logging is good, the user never sees it
- in cli mode logging is bad, will distract from user, 
- need development logging, prob not production 



### Some random thoughts

##### Naming stuff
I spend way too much time naming things.  A good name is very useful, I get
stuck trying to come up with esthetically pleasing and useful names.
Some of the rules of GO don't help.  
Ex:
Start with an interface returning a Name
Then implement it.

```
type Thing interface {
	Name() string
}

type MyThing struct {
	name string
}

func (m *MyThing) Name() string {
	return m.name
}
```

That works very well.... except if you need to make Name public so you 
can marshal/unmarshal the value.  So you end up wanting to name it 
```
 type MyThing struct {
 	Name string `json:"name"`
 }
 
 func (m *MyThing) Name() string {
 	return m.Name
 }
```
But that does not compile because you have a method and field with the same name.
* ValueName (NameValue), yuck
* ThingName, sorta yuck, is redundant   
* use java like getters GetName(), triple yuck  
* use a different language, Nombre, Nomine, 
(does not work if the word is the same, ex. German for Name is Name), I like it.  A little eccentric but...
(of course your IDE will complain about the spelling, so you'll have to add the correct dictionary)

```
 type MyThing struct {
 	Nombre string `json:"name"`
 }
 
 func (m *MyThing) Name() string {
 	return m.Nombre
 }
```

